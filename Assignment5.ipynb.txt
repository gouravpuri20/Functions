{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "x1VCbmBDs09X"
      },
      "source": [
        "# Function\n",
        "\n",
        "Q1.What is the difference between interpreted and compiled languages?\n",
        "\n",
        "ANS  Interpreted vs Compiled Languages:\n",
        "Compiled Languages:\n",
        "* Source code is translated into machine code (binary) before execution\n",
        "* A compiler converts the entire program into executable files (.exe, .out, etc.)\n",
        "* Examples: C, C++, Rust, Go\n",
        "* Execution is faster since code is pre-translated\n",
        "* Errors are caught at compile time\n",
        "* Platform-specific executables are created\n",
        "Interpreted Languages:\n",
        "* Source code is executed line-by-line at runtime\n",
        "* An interpreter reads and executes code directly\n",
        "* Examples: Python, JavaScript, Ruby\n",
        "* Slower execution as translation happens during runtime\n",
        "* More flexibility - can execute code interactively\n",
        "* Platform-independent (as long as interpreter is available)\n",
        "* Errors are caught at runtime\n",
        "Python specifically:\n",
        "* Python is primarily interpreted but uses compilation to bytecode (.pyc files)\n",
        "* Source code → Bytecode → Python Virtual Machine (PVM)\n",
        "* This hybrid approach provides portability while maintaining reasonable performance\n",
        "\n",
        "Q2.What is exception handling in Python?\n",
        "\n",
        "ANS Exception handling in Python is a programming technique that allows you to handle runtime errors gracefully without crashing your program. It provides a way to catch and respond to exceptional circumstances that occur during program execution.\n",
        "Key Components of Exception Handling:\n",
        "1. try block: Contains code that might raise an exception\n",
        "2. except block: Handles specific exceptions when they occur\n",
        "3. else block: Executes when no exceptions are raised in the try block\n",
        "4. finally block: Always executes, regardless of whether an exception occurred\n",
        "Basic Syntax:\n",
        "try: # Code that might raise an exception risky_operation() except SpecificException as e: # Handle specific exception print(f\"An error occurred: {e}\") except Exception as e: # Handle any other exception print(f\"Unexpected error: {e}\") else: # Executes if no exception occurs print(\"Operation completed successfully\") finally: # Always executes print(\"Cleanup operations\")\n",
        "Common Built-in Exceptions:\n",
        "* ValueError: Invalid value for operation\n",
        "* TypeError: Wrong data type\n",
        "* FileNotFoundError: File doesn't exist\n",
        "* ZeroDivisionError: Division by zero\n",
        "* IndexError: List index out of range\n",
        "* KeyError: Dictionary key not found\n",
        "Benefits:\n",
        "* Prevents program crashes\n",
        "* Provides meaningful error messages\n",
        "* Allows graceful error recovery\n",
        "* Separates error handling from main logic\n",
        "* Improves code reliability and user experience\n",
        "Example:\n",
        "try: number = int(input(\"Enter a number: \")) result = 10 / number print(f\"Result: {result}\") except ValueError: print(\"Please enter a valid number\") except ZeroDivisionError: print(\"Cannot divide by zero\") except Exception as e: print(f\"An unexpected error occurred: {e}\") else: print(\"Calculation completed successfully\") finally: print(\"Thank you for using the calculator\")\n",
        "Exception handling is essential for writing robust Python applications that can handle unexpected situations and provide a better user experience.\n",
        "\n",
        "Q3.What is the purpose of the finally block in exception handling?\n",
        "\n",
        "ANS The purpose of the finally block in exception handling is to ensure that certain code executes regardless of whether an exception occurs or not. It provides a guaranteed execution mechanism for cleanup operations and resource management.\n",
        "Key purposes of the finally block:\n",
        "1. Guaranteed Execution: Code in the finally block always runs, whether:\n",
        "\n",
        "\n",
        "    * No exception occurs\n",
        "    * An exception is caught and handled\n",
        "    * An exception is raised but not caught\n",
        "    * A return statement is executed in try/except blocks\n",
        "2. Resource Cleanup: Essential for releasing resources like:\n",
        "\n",
        "\n",
        "    * Closing files\n",
        "    * Releasing database connections\n",
        "    * Freeing network connections\n",
        "    * Cleaning up temporary variables\n",
        "3. Cleanup Operations: Perform necessary cleanup tasks such as:\n",
        "\n",
        "\n",
        "    * Logging completion status\n",
        "    * Restoring system states\n",
        "    * Finalizing operations\n",
        "Syntax:\n",
        "try: # Code that might raise an exception risky_operation() except SomeException: # Handle exception handle_error() finally: # This always executes cleanup_resources()\n",
        "Example:\n",
        "file = None try: file = open(\"data.txt\", \"r\") content = file.read() process_data(content) except FileNotFoundError: print(\"File not found\") except Exception as e: print(f\"Error: {e}\") finally: # This ensures file is closed even if an error occurs if file: file.close() print(\"File closed successfully\")\n",
        "Important Notes:\n",
        "* The finally block executes even if there's a return statement in try/except\n",
        "* If an exception occurs in the finally block, it can override exceptions from try/except\n",
        "* finally is optional but highly recommended for resource management\n",
        "The finally block is crucial for writing robust, reliable Python code that properly manages resources and ensures cleanup operations are performed regardless of program flow.\n",
        "\n",
        "Q4.What is logging in Python?\n",
        "\n",
        "ANS Logging in Python is a built-in module that provides a flexible framework for recording events, messages, and diagnostic information during program execution. It's an essential tool for debugging, monitoring, and maintaining applications.\n",
        "Key Features of Python Logging:\n",
        "1. Event Recording: Captures and stores information about what happens during program execution\n",
        "2. Multiple Severity Levels: Organizes messages by importance (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n",
        "3. Flexible Output: Can send logs to files, console, network, or other destinations\n",
        "4. Configurable Formatting: Customize how log messages appear\n",
        "5. Performance Efficient: Can be easily disabled in production without code changes\n",
        "Basic Logging Levels (in order of severity):\n",
        "* DEBUG: Detailed diagnostic information\n",
        "* INFO: General information about program execution\n",
        "* WARNING: Something unexpected happened, but program continues\n",
        "* ERROR: Serious problem occurred, some functionality failed\n",
        "* CRITICAL: Very serious error, program may not continue\n",
        "Simple Example:\n",
        "import logging\n",
        "Configure logging\n",
        "logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n",
        "Create log messages\n",
        "logging.debug(\"This is a debug message\") logging.info(\"Application started successfully\") logging.warning(\"This is a warning message\") logging.error(\"An error occurred\") logging.critical(\"Critical system failure\")\n",
        "Advantages of Logging:\n",
        "* Better than print statements for debugging\n",
        "* Can be easily turned on/off\n",
        "* Provides timestamps and context\n",
        "* Supports different output destinations\n",
        "* Helps in production monitoring and troubleshooting\n",
        "Logging is crucial for professional Python development as it provides visibility into application behavior and helps identify issues in both development and production environments.\n",
        "\n",
        "Q5.What is the significance of the __del__ method in Python?\n",
        "\n",
        "ANS The del method in Python is a special method (destructor) that is automatically called when an object is about to be destroyed by the garbage collector. It serves as the counterpart to init (constructor) and has several important characteristics and use cases.\n",
        "Key Significance of del method:\n",
        "1. Automatic Cleanup: Called automatically when an object's reference count drops to zero or when the program ends\n",
        "\n",
        "2. Resource Management: Used to release external resources like files, network connections, or database connections\n",
        "\n",
        "3. Memory Management: Helps in cleaning up resources that Python's garbage collector might not handle automatically\n",
        "\n",
        "4. Finalizer Functionality: Acts as a finalizer to perform last-minute cleanup operations\n",
        "Syntax:\n",
        "class MyClass: def init(self, name): self.name = name print(f\"Object {self.name} created\")\n",
        "def __del__(self):\n",
        "    print(f\"Object {self.name} is being destroyed\")\n",
        "Example with Resource Management:\n",
        "class FileManager: def init(self, filename): self.filename = filename self.file = open(filename, 'w') print(f\"File {filename} opened\")\n",
        "def write_data(self, data):\n",
        "    self.file.write(data)\n",
        "\n",
        "def __del__(self):\n",
        "    if hasattr(self, 'file') and not self.file.closed:\n",
        "        self.file.close()\n",
        "        print(f\"File {self.filename} closed automatically\")Usage\n",
        "fm = FileManager(\"test.txt\") fm.write_data(\"Hello World\") del fm # Triggers del method\n",
        "Important Considerations:\n",
        "1. Not Guaranteed Timing: __del__ is called when the object is garbage collected, but the timing is not guaranteed\n",
        "\n",
        "2. Circular References: Objects involved in circular references might not have __del__ called immediately\n",
        "\n",
        "3. Exception Handling: Exceptions in __del__ are ignored and only a warning is printed to stderr\n",
        "\n",
        "4. Better Alternatives: Context managers (with statement) and try/finally blocks are often preferred for resource management\n",
        "Best Practices:\n",
        "* Use __del__ sparingly and only when necessary\n",
        "* Prefer context managers for resource management\n",
        "* Don't rely on __del__ for critical cleanup operations\n",
        "* Keep __del__ methods simple and exception-free\n",
        "The del method provides a safety net for resource cleanup, but explicit resource management using context managers or try/finally blocks is generally more reliable and predictable.\n",
        "\n",
        "Q6.What is the difference between import and from ... import in Python?\n",
        "\n",
        "Ans The difference between import and from ... import in Python:\n",
        "1.import statement:\n",
        "Imports the entire moduleYou need to use the module name as a prefix to access its contentsCreates a namespace for the module\n",
        "import math import os\n",
        "Usage - need to prefix with module name\n",
        "result = math.sqrt(16) current_dir = os.getcwd()\n",
        "2 from ... import statement:\n",
        "Imports specific functions, classes, or variables from a moduleAllows direct access without module prefixCan import everything using * (not recommended)\n",
        "from math import sqrt, pi from os import getcwd\n",
        "Usage - direct access without module prefix\n",
        "result = sqrt(16) current_dir = getcwd()\n",
        "Key Differences:\n",
        "Aspectimportfrom ... importNamespaceCreates module namespaceImports into current namespaceAccessRequires module.function()Direct function() callMemoryLoads entire moduleLoads only specified itemsClarityClear module originLess clear where function comes fromName conflictsAvoided by namespacePossible conflicts with local names\n",
        "Examples:\n",
        "Method 1: import\n",
        "import datetime today = datetime.date.today()\n",
        "Method 2: from ... import\n",
        "from datetime import date today = date.today()\n",
        "Method 3: from ... import with alias\n",
        "from datetime import date as dt today = dt.today()\n",
        "Method 4: import with alias\n",
        "import datetime as dt today = dt.date.today()\n",
        "Best Practices:\n",
        "* Use import for better code readability and avoiding name conflicts\n",
        "* Use from ... import for frequently used functions to reduce typing\n",
        "* Avoid from module import * as it pollutes the namespace\n",
        "* Use aliases when module names are long or to avoid conflicts\n",
        "\n",
        "Q7.How can you handle multiple exceptions in Python?\n",
        "\n",
        "Ans How can you handle multiple exceptions in Python?\n",
        "Python provides several ways to handle multiple exceptions effectively:\n",
        "Multiple except blocks for different exception types:\n",
        "try: # Code that might raise different exceptions num = int(input(\"Enter a number: \")) result = 10 / num my_list = [1, 2, 3] print(my_list[num]) except ValueError: print(\"Invalid input! Please enter a valid number.\") except ZeroDivisionError: print(\"Cannot divide by zero!\") except IndexError: print(\"Index out of range!\")\n",
        "Handling multiple exceptions in a single except block:\n",
        "try: # Code that might raise exceptions num = int(input(\"Enter a number: \")) result = 10 / num my_list = [1, 2, 3] print(my_list[num]) except (ValueError, ZeroDivisionError, IndexError) as e: print(f\"An error occurred: {e}\") print(f\"Error type: {type(e).name}\")\n",
        "Using a general exception handler:\n",
        "try: # Risky code num = int(input(\"Enter a number: \")) result = 10 / num my_list = [1, 2, 3] print(my_list[num]) except ValueError: print(\"Invalid input!\") except ZeroDivisionError: print(\"Cannot divide by zero!\") except Exception as e: print(f\"Unexpected error: {e}\")\n",
        "Nested try-except blocks:\n",
        "try: try: num = int(input(\"Enter a number: \")) except ValueError: print(\"Invalid number format!\") raise # Re-raise the exception\n",
        "try:\n",
        "    result = 10 / num\n",
        "    print(f\"Result: {result}\")\n",
        "except ZeroDivisionError:\n",
        "    print(\"Cannot divide by zero!\")\n",
        "    \n",
        "except Exception as e: print(f\"Outer exception handler: {e}\")\n",
        "Complete exception handling structure:\n",
        "try: # Code that might raise exceptions file_name = input(\"Enter file name: \") with open(file_name, 'r') as file: content = file.read() number = int(content.strip()) result = 100 / number print(f\"Result: {result}\") except FileNotFoundError: print(\"File not found!\") except PermissionError: print(\"Permission denied to access the file!\") except ValueError: print(\"File content is not a valid number!\") except ZeroDivisionError: print(\"Cannot divide by zero!\") except Exception as e: print(f\"Unexpected error: {type(e).name}: {e}\") else: print(\"Operation completed successfully!\") finally: print(\"Cleanup operations completed.\")\n",
        "Best Practices:\n",
        "* Handle specific exceptions first, then general ones\n",
        "* Use meaningful error messages\n",
        "* Log exceptions for debugging purposes\n",
        "* Don't catch exceptions you can't handle meaningfully\n",
        "* Use finally block for cleanup operations\n",
        "* Consider using else block for code that should run only if no exceptions occurred\n",
        "\n",
        "Q8.What is the purpose of the with statement when handling files in Python?\n",
        "\n",
        "Ans The purpose of the with statement when handling files in Python:\n",
        "The with statement is used for context management and provides a clean, safe way to handle files. Its main purposes are:\n",
        "1. Automatic Resource Management: It automatically opens and closes files, ensuring proper cleanup even if an error occurs.\n",
        "\n",
        "2. Exception Safety: If an exception is raised while the file is open, the with statement guarantees the file will still be closed properly.\n",
        "\n",
        "3. Cleaner Code: It eliminates the need to manually call file.close() and reduces boilerplate code.\n",
        "\n",
        "4. Memory Efficiency: It prevents memory leaks by ensuring files are properly closed and resources are freed.\n",
        "Example:\n",
        "Using with statement (recommended)\n",
        "with open('example.txt', 'r') as file: content = file.read() print(content)\n",
        "File is automatically closed here, even if an exception occursWithout with statement (not recommended)\n",
        "file = open('example.txt', 'r') try: content = file.read() print(content) finally: file.close() # Must manually close\n",
        "Key Benefits:\n",
        "* Guarantees file closure\n",
        "* Handles exceptions gracefully\n",
        "* Follows Python's principle of \"explicit is better than implicit\"\n",
        "* Implements the context manager protocol (__enter__ and __exit__ methods)\n",
        "The with statement is considered a Python best practice for file handling because it makes code more reliable and easier to maintain.\n",
        "\n",
        "Q9.What is the difference between multithreading and multiprocessing?\n",
        "\n",
        "Ans The difference between multithreading and multiprocessing in Python:\n",
        "Multithreading:\n",
        "* Uses multiple threads within a single process\n",
        "* Threads share the same memory space and resources\n",
        "* Limited by Python's Global Interpreter Lock (GIL)\n",
        "* Better for I/O-bound tasks (file operations, network requests)\n",
        "* Lower memory overhead\n",
        "* Faster communication between threads\n",
        "Multiprocessing:\n",
        "* Uses multiple separate processes\n",
        "* Each process has its own memory space\n",
        "* Not limited by GIL - true parallelism\n",
        "* Better for CPU-bound tasks (calculations, data processing)\n",
        "* Higher memory overhead\n",
        "* Inter-process communication is more complex\n",
        "Key Differences:\n",
        "AspectMultithreadingMultiprocessingMemorySharedSeparateGIL ImpactLimited by GILNot affected by GILBest forI/O-bound tasksCPU-bound tasksOverheadLowHighCommunicationFast (shared memory)Slower (IPC required)\n",
        "Examples:\n",
        "Multithreading example\n",
        "import threading import time\n",
        "def worker(name): print(f\"Worker {name} starting\") time.sleep(2) print(f\"Worker {name} finished\")\n",
        "Create threads\n",
        "threads = [] for i in range(3): t = threading.Thread(target=worker, args=(i,)) threads.append(t) t.start()\n",
        "Wait for all threads to complete\n",
        "for t in threads: t.join()\n",
        "Multiprocessing example\n",
        "import multiprocessing import time\n",
        "def worker(name): print(f\"Process {name} starting\") time.sleep(2) print(f\"Process {name} finished\")\n",
        "if name == 'main': # Create processes processes = [] for i in range(3): p = multiprocessing.Process(target=worker, args=(i,)) processes.append(p) p.start()\n",
        "# Wait for all processes to complete\n",
        "for p in processes:\n",
        "    p.join()\n",
        "When to use:\n",
        "* Multithreading: File I/O, web scraping, API calls\n",
        "* Multiprocessing: Mathematical calculations, image processing, data analysis.\n",
        "\n",
        "Q10.What are the advantages of using logging in a program?\n",
        "\n",
        "Ans Advantages of Using Logging in a Program:1. Debugging and Troubleshooting\n",
        "\n",
        "\n",
        "    * Helps identify where errors occur in the code\n",
        "    * Provides detailed information about program execution flow\n",
        "    * Makes it easier to trace bugs and fix issues\n",
        "2. Monitoring Application Performance\n",
        "\n",
        "\n",
        "    * Track how long operations take\n",
        "    * Monitor resource usage and bottlenecks\n",
        "    * Identify performance issues in production\n",
        "3. Audit Trail and Compliance\n",
        "\n",
        "\n",
        "    * Keep records of user actions and system events\n",
        "    * Meet regulatory requirements for data handling\n",
        "    * Maintain accountability and security logs\n",
        "4. Different Log Levels\n",
        "\n",
        "\n",
        "    * DEBUG: Detailed diagnostic information\n",
        "    * INFO: General information about program execution\n",
        "    * WARNING: Potential issues that don't stop execution\n",
        "    * ERROR: Serious problems that caused failures\n",
        "    * CRITICAL: Very serious errors that may stop the program\n",
        "5. Flexible Output Options\n",
        "\n",
        "\n",
        "    * Log to files for permanent storage\n",
        "    * Log to console for immediate feedback\n",
        "    * Send logs to remote servers or databases\n",
        "    * Configure different formats for different audiences\n",
        "6. Production Environment Benefits\n",
        "\n",
        "\n",
        "    * Monitor applications without stopping them\n",
        "    * Analyze issues that only occur in production\n",
        "    * Collect data for improving system reliability\n",
        "7. Better Than Print Statements\n",
        "\n",
        "\n",
        "    * Can be easily enabled/disabled\n",
        "    * Formatted consistently\n",
        "    * Categorized by severity\n",
        "    * Can be filtered and searched efficiently\n",
        "8. Maintenance and Support\n",
        "\n",
        "\n",
        "    * Helps support teams understand user issues\n",
        "    * Provides historical data for trend analysis\n",
        "    * Reduces time spent on troubleshooting\n",
        "\n",
        "Q11.What is memory management in Python?\n",
        "\n",
        "Ans Memory management in Python refers to how Python automatically handles the allocation and deallocation of memory for objects during program execution. Here are the key aspects:\n",
        "Automatic Memory Management\n",
        "Python handles memory allocation automatically when you create objectsYou don't need to manually allocate or deallocate memory like in C/C++Memory is allocated from the heap when objects are created\n",
        "Reference Counting\n",
        "Python keeps track of how many references point to each objectWhen an object's reference count drops to zero, it becomes eligible for garbage collectionThis happens automatically when variables go out of scope or are reassigned\n",
        "Garbage Collection\n",
        "Python has a built-in garbage collector that handles cyclic referencesUses a generational garbage collection algorithmAutomatically frees memory from objects that are no longer accessible\n",
        "Memory Pools\n",
        "Python uses memory pools for efficient allocation of small objectsReduces fragmentation and improves performanceObjects of similar sizes are grouped together\n",
        "Key Components:\n",
        "import gc import sys\n",
        "Check reference count\n",
        "obj = [1, 2, 3] print(sys.getrefcount(obj)) # Shows reference count\n",
        "Manual garbage collection\n",
        "gc.collect() # Force garbage collection\n",
        "Check memory usage\n",
        "import psutil import os process = os.getpid() memory_info = psutil.Process(process).memory_info() print(f\"Memory usage: {memory_info.rss / 1024 / 1024:.2f} MB\")\n",
        "Best Practices:\n",
        "Avoid circular references when possibleUse context managers (with statements) for resource managementDelete large objects explicitly when no longer neededUse generators for large datasets to save memory\n",
        "Memory Optimization Techniques:\n",
        "Use slots in classes to reduce memory overheadUse appropriate data structures (sets vs lists)Implement lazy loading for large datasets.\n",
        "\n",
        "Q12.What are the basic steps involved in exception handling in Python?\n",
        "\n",
        "Ans The basic steps involved in exception handling in Python are:1. Try Block\n",
        "\n",
        "\n",
        "    * Contains the code that might raise an exception\n",
        "    * Python attempts to execute this code first\n",
        "    * If no exception occurs, the except block is skipped\n",
        "2. Except Block\n",
        "\n",
        "\n",
        "    * Contains code that handles specific exceptions\n",
        "    * Executed only when an exception occurs in the try block\n",
        "    * Can handle specific exception types or all exceptions\n",
        "3. Else Block (Optional)\n",
        "\n",
        "\n",
        "    * Executed only if no exception occurs in the try block\n",
        "    * Used for code that should run only when try block succeeds\n",
        "    * Helps separate error handling from normal flow\n",
        "4. Finally Block (Optional)\n",
        "\n",
        "\n",
        "    * Always executed, regardless of whether an exception occurred\n",
        "    * Used for cleanup operations (closing files, releasing resources)\n",
        "    * Runs even if an exception is not handled\n",
        "5. Basic Syntax Structure:\n",
        "try: # Code that might raise an exception risky_operation() except SpecificException as e: # Handle specific exception print(f\"Specific error occurred: {e}\") except Exception as e: # Handle any other exception print(f\"An error occurred: {e}\") else: # Executed if no exception occurs print(\"Operation successful\") finally: # Always executed print(\"Cleanup operations\")\n",
        "1. Example Implementation:\n",
        "try: num = int(input(\"Enter a number: \")) result = 10 / num print(f\"Result: {result}\") except ValueError: print(\"Invalid input! Please enter a valid number.\") except ZeroDivisionError: print(\"Cannot divide by zero!\") except Exception as e: print(f\"Unexpected error: {e}\") else: print(\"Division completed successfully\") finally: print(\"End of operation\")\n",
        "1. Key Points:\n",
        "\n",
        "    * Multiple except blocks can handle different exception types\n",
        "    * Use specific exceptions before general ones\n",
        "    * The finally block is crucial for resource management\n",
        "    * Exception handling prevents program crashes and provides graceful error recovery\n",
        "\n",
        "Q13.Why is memory management important in Python?\n",
        "\n",
        "Ans Memory management is crucial in Python for several important reasons:\n",
        "Performance Optimization\n",
        "Efficient memory usage leads to faster program executionPrevents memory leaks that can slow down applications over timeReduces memory fragmentation for better system performance\n",
        "Resource Conservation\n",
        "Prevents excessive memory consumption that could affect other applicationsImportant for systems with limited memory resourcesEnables running multiple Python programs simultaneously\n",
        "Application Stability\n",
        "Prevents out-of-memory errors that can crash programsEnsures long-running applications remain stableReduces system freezes and crashes\n",
        "Scalability\n",
        "Critical for applications handling large datasetsEnables processing of bigger data without system limitationsImportant for web applications serving multiple users\n",
        "Cost Efficiency\n",
        "Reduces hardware requirements in production environmentsLower cloud computing costs due to reduced memory usageBetter resource utilization in server environments\n",
        "User Experience\n",
        "Prevents application slowdowns and freezingEnsures responsive user interfacesMaintains consistent performance\n",
        "System Health\n",
        "Prevents memory exhaustion that affects the entire systemMaintains optimal operating system performanceReduces the need for system restarts\n",
        "Example of Poor vs Good Memory Management:\n",
        "Poor memory management\n",
        "def bad_memory_usage(): large_lists = [] for i in range(1000): large_lists.append([0] * 1000000) # Creates unnecessary large objects return large_lists\n",
        "Good memory management\n",
        "def good_memory_usage(): for i in range(1000): data = [0] * 1000000 process_data(data) del data # Explicitly free memory\n",
        "Production Environment Considerations\n",
        "Critical for server applications running 24/7Important for microservices and containerized applicationsEssential for applications deployed on limited-resource environments\n",
        "\n",
        "Q14.What is the role of try and except in exception handling?\n",
        "\n",
        "AnsThe try and except blocks in Python serve as the foundation of exception handling, providing a structured way to handle errors gracefully. Here's their role:\n",
        "Error Prevention and Control\n",
        "try block contains code that might raise an exceptionexcept block defines how to handle specific exceptions when they occurPrevents program crashes by catching and managing errors\n",
        "Graceful Error Handling\n",
        "try: result = 10 / 0 # This will raise ZeroDivisionError except ZeroDivisionError: print(\"Cannot divide by zero!\") result = 0\n",
        "Multiple Exception Handling\n",
        "try: file = open(\"nonexistent.txt\", \"r\") data = file.read() except FileNotFoundError: print(\"File not found!\") except PermissionError: print(\"Permission denied!\") except Exception as e: print(f\"An unexpected error occurred: {e}\")\n",
        "Program Flow Control\n",
        "Allows programs to continue execution even when errors occurProvides alternative execution paths when exceptions are encounteredMaintains application stability\n",
        "User Experience Enhancement\n",
        "Displays meaningful error messages instead of cryptic system errorsAllows for retry mechanisms and fallback optionsKeeps applications running smoothly\n",
        "Resource Management\n",
        "Enables proper cleanup of resources even when errors occurWorks with finally block for guaranteed cleanupPrevents resource leaks\n",
        "Debugging and Logging\n",
        "try: risky_operation() except Exception as e: logging.error(f\"Operation failed: {e}\") # Handle the error appropriately\n",
        "Key Benefits:\n",
        "* Robustness: Makes programs more reliable and stable\n",
        "* Maintainability: Centralizes error handling logic\n",
        "* User-Friendly: Provides better error messages for users\n",
        "* Control: Allows selective handling of different error types\n",
        "\n",
        "Q15.How does Python's garbage collection system work?\n",
        "\n",
        "Ans Python's garbage collection system works through an automatic memory management process that reclaims memory occupied by objects that are no longer reachable or referenced. Here's how it operates:Reference Counting (Primary Mechanism)Every object in Python has a reference count that tracks how many references point to itWhen an object's reference count drops to zero, it's immediately deallocatedThis handles most memory cleanup automaticallyExample of reference counting\n",
        "a = [1, 2, 3] # Reference count = 1 b = a # Reference count = 2 del a # Reference count = 1 del b # Reference count = 0, object is deallocated\n",
        "Cyclic Garbage CollectionHandles circular references that reference counting can't resolveUses a generational garbage collector with three generations (0, 1, 2)Objects start in generation 0 and get promoted if they survive collection cyclesExample of circular reference\n",
        "class Node: def init(self, value): self.value = value self.parent = None self.children = []\n",
        "Creating circular reference\n",
        "parent = Node(\"parent\") child = Node(\"child\") parent.children.append(child) child.parent = parent # Circular reference created\n",
        "Generation-Based Collection\n",
        "Generation 0: New objects, collected most frequentlyGeneration 1: Objects that survived one collection cycleGeneration 2: Long-lived objects, collected least frequently\n",
        "Collection Triggers\n",
        "Automatic triggering based on allocation/deallocation thresholdsManual triggering using the gc moduleCollection occurs when generation thresholds are exceeded\n",
        "import gc\n",
        "Manual garbage collection\n",
        "gc.collect()\n",
        "Check collection statistics\n",
        "print(gc.get_stats())\n",
        "Disable/enable automatic collection\n",
        "gc.disable() gc.enable()\n",
        "Weak ReferencesAllow referencing objects without affecting their reference countUseful for avoiding circular references in certain design patterns\n",
        "import weakref\n",
        "class MyClass: def init(self, name): self.name = name\n",
        "obj = MyClass(\"test\") weak_ref = weakref.ref(obj) # Doesn't increase reference count\n",
        "Memory Pools and Arenas\n",
        "Python uses memory pools for small objects (< 512 bytes)Reduces fragmentation and improves allocation speedArenas manage larger memory blocks\n",
        "Garbage Collection Process\n",
        "Mark Phase: Identifies reachable objects starting from root referencesSweep Phase: Deallocates unreachable objectsPromotion: Surviving objects move to the next generation\n",
        "Key Characteristics\n",
        "Automatic: No manual memory management requiredGenerational: Optimized for typical object lifetimesIncremental: Spreads collection work across multiple cyclesConfigurable: Thresholds and behavior can be adjusted\n",
        "Performance Considerations import gc\n",
        "Monitor garbage collection\n",
        "def monitor_gc(): print(f\"Collections: {gc.get_count()}\") print(f\"Thresholds: {gc.get_threshold()}\")\n",
        "Optimize for specific use cases\n",
        "gc.set_threshold(700, 10, 10) # Adjust collection frequency\n",
        "Best PracticesAvoid circular references when possibleUse context managers for resource cleanupConsider weak references for observer patternsMonitor memory usage in long-running applicationsUse del methods carefully as they can interfere with garbage collection\n",
        "The garbage collection system ensures efficient memory usage while maintaining Python's ease of use by handling memory management automatically behind the scenes.\n",
        "\n",
        "Q16.What is the purpose of the else block in exception handling?\n",
        "\n",
        "Ans The else block in exception handling serves a specific and important purpose: it executes only when no exception occurs in the corresponding try block.\n",
        "Purpose and Benefits: 1. Clean Separation of Logic: The else block allows you to separate the code that might raise exceptions from the code that should only run when everything goes smoothly.\n",
        "2. Improved Readability: It makes the code's intent clearer by explicitly showing what should happen in the success case.\n",
        "\n",
        "3. Prevents Unintended Exception Catching: Code in the else block is not protected by the except handlers, which means if an exception occurs there, it won't be accidentally caught by the same exception handlers.\n",
        "Syntax: try: # Code that might raise an exception risky_operation() except SomeException: # Handle the exception handle_error() else: # This runs only if no exception occurred in try block success_operation() finally: # This always runs (optional) cleanup()\n",
        "Practical Example: def read_and_process_file(filename): try: file = open(filename, 'r') except FileNotFoundError: print(f\"Error: File '{filename}' not found\") return None else: # This only runs if file was opened successfully content = file.read() file.close() print(\"File read successfully\") return content.upper()\n",
        "Usage\n",
        "result = read_and_process_file(\"data.txt\") if result: print(f\"Processed content: {result}\")\n",
        "Key Points: * The else block is optional * It executes only if no exception was raised in the try block * If an exception occurs in the else block, it will not be caught by the preceding except handlers * It runs before any finally block * It's particularly useful for code that should only execute when the risky operation succeeds\n",
        "\n",
        "Q17.What are the common logging levels in Python?\n",
        "\n",
        "Ans Common Logging Levels in Python\n",
        "Python's logging module provides several predefined logging levels that indicate the severity and importance of log messages. Here are the standard logging levels in order of increasing severity:\n",
        "DEBUG (Level 10)\n",
        "Lowest levelUsed for detailed diagnostic informationTypically only of interest when diagnosing problemsUsually disabled in production\n",
        "INFO (Level 20)\n",
        "General informational messagesConfirms that things are working as expectedUsed to track the general flow of the application\n",
        "WARNING (Level 30)\n",
        "Indicates something unexpected happened or potential problemsThe software is still working as expectedDefault logging level\n",
        "ERROR (Level 40)\n",
        "Serious problems that prevented a function from executingThe software was unable to perform some operationMore serious than warnings\n",
        "CRITICAL (Level 50)\n",
        "Highest levelVery serious errors that may cause the program to terminateIndicates the program may not be able to continue running\n",
        "Usage Example:\n",
        "import logging\n",
        "Configure logging\n",
        "logging.basicConfig(level=logging.DEBUG, format='%(levelname)s: %(message)s')\n",
        "Using different logging levels\n",
        "logging.debug(\"This is a debug message\") logging.info(\"This is an info message\") logging.warning(\"This is a warning message\") logging.error(\"This is an error message\") logging.critical(\"This is a critical message\")\n",
        "Setting Log Levels:\n",
        "Set different threshold levels\n",
        "logging.getLogger().setLevel(logging.WARNING) # Only WARNING and above will be shown logging.getLogger().setLevel(logging.INFO) # INFO and above will be shown\n",
        "Key Points:\n",
        "* Each level has a numeric value that determines its priority\n",
        "* When you set a logging level, only messages at that level or higher will be displayed\n",
        "* You can create custom levels if needed, though it's rarely necessary\n",
        "* The default level is WARNING, meaning DEBUG and INFO messages are not shown unless explicitly configured\n",
        "\n",
        "Q18.What is the difference between os.fork() and multiprocessing in Python?\n",
        "\n",
        "Ans The main differences between os.fork() and the multiprocessing module in Python are:\n",
        "Platform Compatibility:\n",
        "os.fork(): Only available on Unix-like systems (Linux, macOS). Not available on Windows.multiprocessing: Cross-platform solution that works on Windows, Linux, macOS, and other operating systems.\n",
        "Level of Abstraction:\n",
        "os.fork(): Low-level system call that directly creates a copy of the current processmultiprocessing: High-level module that provides a more user-friendly interface for parallel processing\n",
        "Process Creation Method:\n",
        "os.fork(): Creates an exact copy of the parent process, including memory spacemultiprocessing: Can use different methods (fork, spawn, forkserver) depending on the platform\n",
        "Memory Sharing:\n",
        "os.fork(): Child process initially shares memory with parent (copy-on-write)multiprocessing: Provides controlled memory sharing through shared objects and queues\n",
        "Communication:\n",
        "os.fork(): Basic inter-process communication through pipes, signals, or shared memorymultiprocessing: Built-in communication mechanisms like Queue, Pipe, Manager, etc.\n",
        "Resource Management:\n",
        "os.fork(): Manual process management and cleanup requiredmultiprocessing: Automatic process lifecycle management and cleanup\n",
        "Example Comparison:\n",
        "Using os.fork() (Unix only)\n",
        "import os import sys\n",
        "pid = os.fork() if pid == 0: # Child process print(\"Child process\") else: # Parent process print(\"Parent process\") os.waitpid(pid, 0) # Wait for child\n",
        "Using multiprocessing (Cross-platform)\n",
        "import multiprocessing\n",
        "def worker(): print(\"Worker process\")\n",
        "if name == \"main\": process = multiprocessing.Process(target=worker) process.start() process.join() # Wait for process to complete\n",
        "When to Use:\n",
        "* Use os.fork() when you need low-level control and are working only on Unix systems\n",
        "* Use multiprocessing for portable, high-level parallel processing with better abstractions and built-in communication tools\n",
        "\n",
        "Q19.What is the importance of closing a file in Python?\n",
        "\n",
        "Ans The importance of closing a file in Python:1. Resource Management:\n",
        "\n",
        "\n",
        "    * Files are system resources that consume memory and file descriptors\n",
        "    * Each open file uses a file descriptor, and systems have limits on how many can be open simultaneously\n",
        "    * Closing files frees up these resources for other processes\n",
        "2. Data Integrity:\n",
        "\n",
        "\n",
        "    * Ensures all buffered data is written to the file\n",
        "    * Prevents data loss if the program terminates unexpectedly\n",
        "    * Guarantees that all changes are saved to disk\n",
        "3. Memory Efficiency:\n",
        "\n",
        "\n",
        "    * Releases memory buffers associated with the file\n",
        "    * Prevents memory leaks in long-running applications\n",
        "    * Keeps memory usage optimized\n",
        "4. Platform Compatibility:\n",
        "\n",
        "\n",
        "    * Some operating systems have strict limits on open file handles\n",
        "    * Prevents \"too many open files\" errors\n",
        "    * Ensures consistent behavior across different platforms\n",
        "5. Best Practices and Clean Code:\n",
        "\n",
        "\n",
        "    * Following proper file handling conventions\n",
        "    * Makes code more maintainable and professional\n",
        "    * Prevents potential issues in production environments\n",
        "Methods to Ensure Files are Closed:\n",
        "Method 1: Manual closing (not recommended)\n",
        "file = open(\"example.txt\", \"r\") content = file.read() file.close() # Must remember to close\n",
        "Method 2: Using try-finally block\n",
        "file = open(\"example.txt\", \"r\") try: content = file.read() finally: file.close() # Ensures file is closed even if error occurs\n",
        "Method 3: Using context manager (recommended)\n",
        "with open(\"example.txt\", \"r\") as file: content = file.read()\n",
        "File is automatically closed when exiting the with block\n",
        "Consequences of Not Closing Files:\n",
        "* Resource exhaustion leading to program crashes\n",
        "* Data corruption or loss\n",
        "* Performance degradation\n",
        "* System instability in extreme cases\n",
        "* Difficulty debugging file-related issues\n",
        "\n",
        "Q20.What is the difference between file.read() and file.readline() in Python?\n",
        "The difference between file.read() and file.readline() in Python:\n",
        "file.read():\n",
        "Reads the entire file content at onceReturns all remaining content as a single stringCan optionally take a size parameter to read specific number of charactersMoves the file pointer to the end of the file (or specified position)\n",
        "file.readline():\n",
        "Reads only one line at a timeReturns a single line as a string (including the newline character '\\n')Moves the file pointer to the beginning of the next lineReturns an empty string when end of file is reached\n",
        "Examples:\n",
        "Using file.read()\n",
        "with open(\"example.txt\", \"r\") as file: content = file.read() # Reads entire file print(content) # Prints all content at once\n",
        "Using file.read() with size parameter\n",
        "with open(\"example.txt\", \"r\") as file: content = file.read(10) # Reads first 10 characters print(content)\n",
        "Using file.readline()\n",
        "with open(\"example.txt\", \"r\") as file: line1 = file.readline() # Reads first line line2 = file.readline() # Reads second line print(line1) # Prints first line print(line2) # Prints second line\n",
        "Reading all lines using readline()\n",
        "with open(\"example.txt\", \"r\") as file: while True: line = file.readline() if not line: # Empty string means end of file break print(line.strip()) # strip() removes newline character\n",
        "Key Differences:\n",
        "Aspectfile.read()file.readline()Amount of dataEntire file or specified bytesOne line at a timeMemory usageHigh for large filesLow, efficient for large filesReturn valueSingle string with all contentSingle string with one lineFile pointerMoves to end (or specified position)Moves to next lineBest use caseSmall files, need all contentLarge files, line-by-line processing\n",
        "When to use which:\n",
        "* Use read() when you need to process the entire file content at once\n",
        "* Use readline() when processing large files line by line to save memory\n",
        "* Use readline() when you need to process files sequentially without loading everything into memory\n",
        "\n",
        "Q21.What is the logging module in Python used for?\n",
        "\n",
        "Ans The logging module in Python is used for:\n",
        "Primary Purpose: The logging module provides a flexible framework for emitting log messages from Python programs. It's used to track events that happen when software runs, helping developers understand program behavior and diagnose issues.\n",
        "Key Uses:\n",
        "1. Debugging and Troubleshooting:\n",
        "\n",
        "\n",
        "    * Track program execution flow\n",
        "    * Identify where errors occur\n",
        "    * Monitor variable values and program state\n",
        "2. Error and Exception Tracking:\n",
        "\n",
        "\n",
        "    * Record exceptions and error details\n",
        "    * Capture stack traces for debugging\n",
        "    * Log error severity levels\n",
        "3. Application Monitoring:\n",
        "\n",
        "\n",
        "    * Monitor application performance\n",
        "    * Track user activities\n",
        "    * Record system resource usage\n",
        "4. Audit Trails:\n",
        "\n",
        "\n",
        "    * Keep records of important events\n",
        "    * Track user actions for security\n",
        "    * Maintain compliance logs\n",
        "Logging Levels:\n",
        "* DEBUG: Detailed diagnostic information\n",
        "* INFO: General information about program execution\n",
        "* WARNING: Something unexpected happened but program continues\n",
        "* ERROR: Serious problem occurred\n",
        "* CRITICAL: Very serious error, program may stop\n",
        "Basic Example:\n",
        "import logging\n",
        "Configure logging\n",
        "logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n",
        "Use different log levels\n",
        "logging.debug(\"This is a debug message\") logging.info(\"Application started successfully\") logging.warning(\"This is a warning message\") logging.error(\"An error occurred\") logging.critical(\"Critical error - application stopping\")\n",
        "Advanced Features:\n",
        "* Multiple loggers for different modules\n",
        "* Different output destinations (file, console, network)\n",
        "* Log rotation and archiving\n",
        "* Custom formatting and filtering\n",
        "* Handler configuration for complex logging setups\n",
        "Benefits:\n",
        "* Better than print statements for production code\n",
        "* Configurable output levels and destinations\n",
        "* Thread-safe logging operations\n",
        "* Standardized logging format across applications\n",
        "* Easy to disable/enable different log levels\n",
        "The logging module is essential for professional Python development as it provides visibility into application behavior without cluttering code with print statements.\n",
        "\n",
        "Q22.What is the os module in Python used for in file handling?\n",
        "\n",
        "Ans The os module in Python is a powerful built-in module that provides a way to interact with the operating system, particularly useful for file and directory operations. Here's how it's used in file handling:\n",
        "Key Functions for File Handling:\n",
        "1. Path Operations:\n",
        "\n",
        "\n",
        "    * os.path.join() - Safely join file paths across different operating systems\n",
        "    * os.path.exists() - Check if a file or directory exists\n",
        "    * os.path.isfile() - Check if path is a file\n",
        "    * os.path.isdir() - Check if path is a directory\n",
        "    * os.path.basename() - Get filename from path\n",
        "    * os.path.dirname() - Get directory name from path\n",
        "2. Directory Operations:\n",
        "\n",
        "\n",
        "    * os.getcwd() - Get current working directory\n",
        "    * os.chdir() - Change current directory\n",
        "    * os.mkdir() - Create a directory\n",
        "    * os.makedirs() - Create directories recursively\n",
        "    * os.rmdir() - Remove directory\n",
        "    * os.removedirs() - Remove directories recursively\n",
        "    * os.listdir() - List directory contents\n",
        "3. File Operations:\n",
        "\n",
        "\n",
        "    * os.remove() - Delete a file\n",
        "    * os.rename() - Rename a file or directory\n",
        "    * os.stat() - Get file statistics (size, modification time, etc.)\n",
        "Example Usage:\n",
        "import os\n",
        "Get current directory\n",
        "current_dir = os.getcwd() print(f\"Current directory: {current_dir}\")\n",
        "Create a safe file path\n",
        "file_path = os.path.join(current_dir, \"data\", \"example.txt\")\n",
        "Check if file exists\n",
        "if os.path.exists(file_path): print(\"File exists\") # Get file size file_size = os.path.getsize(file_path) print(f\"File size: {file_size} bytes\")\n",
        "List files in directory\n",
        "files = os.listdir(\".\") for file in files: if os.path.isfile(file): print(f\"File: {file}\") elif os.path.isdir(file): print(f\"Directory: {file}\")\n",
        "Create directory if it doesn't exist\n",
        "data_dir = \"data\" if not os.path.exists(data_dir): os.mkdir(data_dir)\n",
        "Benefits:\n",
        "* Cross-platform compatibility - Works on Windows, macOS, and Linux\n",
        "* Safe path handling - Handles different path separators automatically\n",
        "* File system operations - Comprehensive file and directory management\n",
        "* Error handling - Raises appropriate exceptions for invalid operations\n",
        "* Integration with file I/O - Works seamlessly with Python's file handling functions\n",
        "The os module is essential for robust file handling as it provides the foundation for interacting with the file system in a platform-independent way.The os module in Python is a powerful built-in module that provides a way to interact with the operating system, particularly useful for file and directory operations. Here's how it's used in file handling:\n",
        "Key Functions for File Handling:\n",
        "1. Path Operations:\n",
        "\n",
        "\n",
        "    * os.path.join() - Safely join file paths across different operating systems\n",
        "    * os.path.exists() - Check if a file or directory exists\n",
        "    * os.path.isfile() - Check if path is a file\n",
        "    * os.path.isdir() - Check if path is a directory\n",
        "    * os.path.basename() - Get filename from path\n",
        "    * os.path.dirname() - Get directory name from path\n",
        "2. Directory Operations:\n",
        "\n",
        "\n",
        "    * os.getcwd() - Get current working directory\n",
        "    * os.chdir() - Change current directory\n",
        "    * os.mkdir() - Create a directory\n",
        "    * os.makedirs() - Create directories recursively\n",
        "    * os.rmdir() - Remove directory\n",
        "    * os.removedirs() - Remove directories recursively\n",
        "    * os.listdir() - List directory contents\n",
        "3. File Operations:\n",
        "\n",
        "\n",
        "    * os.remove() - Delete a file\n",
        "    * os.rename() - Rename a file or directory\n",
        "    * os.stat() - Get file statistics (size, modification time, etc.)\n",
        "Example Usage:\n",
        "import os\n",
        "Get current directory\n",
        "current_dir = os.getcwd() print(f\"Current directory: {current_dir}\")\n",
        "Create a safe file path\n",
        "file_path = os.path.join(current_dir, \"data\", \"example.txt\")\n",
        "Check if file exists\n",
        "if os.path.exists(file_path): print(\"File exists\") # Get file size file_size = os.path.getsize(file_path) print(f\"File size: {file_size} bytes\")\n",
        "List files in directory\n",
        "files = os.listdir(\".\") for file in files: if os.path.isfile(file): print(f\"File: {file}\") elif os.path.isdir(file): print(f\"Directory: {file}\")\n",
        "Create directory if it doesn't exist\n",
        "data_dir = \"data\" if not os.path.exists(data_dir): os.mkdir(data_dir)\n",
        "Benefits:\n",
        "* Cross-platform compatibility - Works on Windows, macOS, and Linux\n",
        "* Safe path handling - Handles different path separators automatically\n",
        "* File system operations - Comprehensive file and directory management\n",
        "* Error handling - Raises appropriate exceptions for invalid operations\n",
        "* Integration with file I/O - Works seamlessly with Python's file handling functions\n",
        "The os module is essential for robust file handling as it provides the foundation for interacting with the file system in a platform-independent way.\n",
        "\n",
        "Q23.What are the challenges associated with memory management in Python?\n",
        "\n",
        "Ans Challenges Associated with Memory Management in Python:\n",
        "Automatic Memory Management Overhead\n",
        "Python's garbage collection can introduce performance overheadAutomatic allocation/deallocation may not always be optimal for specific use casesLess control over when memory is freed compared to manual memory management\n",
        "Memory Leaks\n",
        "Circular references can prevent garbage collectionObjects that reference each other may not be automatically freedLong-running applications can accumulate memory over time\n",
        "Reference Counting Issues\n",
        "Python uses reference counting which can be inefficient for complex data structuresCircular references require additional cycle detectionReference counting overhead on every assignment/deletion\n",
        "Large Object Handling\n",
        "Loading large datasets into memory can cause performance issuesPython objects have overhead (each object stores type information, reference count, etc.)Memory fragmentation with frequent allocation/deallocation of large objects\n",
        "Global Interpreter Lock (GIL) Impact\n",
        "GIL can affect memory access patterns in multi-threaded applicationsLimits true parallelism which can impact memory-intensive operations\n",
        "Memory Profiling Complexity\n",
        "Difficult to track exact memory usage due to Python's abstraction layersHidden memory consumption by internal data structuresComplex debugging of memory-related performance issues\n",
        "Immutable Object Creation\n",
        "Strings, tuples, and numbers create new objects on modificationCan lead to excessive memory usage in loops or frequent operationsTemporary object creation during operations\n",
        "Third-party Library Memory Management\n",
        "External libraries (C extensions) may have different memory management patternsMemory allocated by C libraries may not be tracked by Python's garbage collectorPotential for memory leaks in poorly written extensions\n",
        "Solutions and Best Practices:\n",
        "* Use memory profilers (memory_profiler, tracemalloc)\n",
        "* Implement proper cleanup in context managers\n",
        "* Use generators for large datasets\n",
        "* Be aware of circular references\n",
        "* Consider using slots for memory-efficient classes\n",
        "* Use weak references when appropriate\n",
        "\n",
        "Q24.How do you raise an exception manually in Python?\n",
        "\n",
        "Ans In Python, you can raise exceptions manually using the raise statement. This allows you to trigger exceptions intentionally when certain conditions are met or when you want to handle specific error scenarios.\n",
        "Basic Syntax:\n",
        "raise ExceptionType(\"Error message\")\n",
        "Common Ways to Raise Exceptions:\n",
        "1. Raising Built-in Exceptions:Raise a ValueError\n",
        "raise ValueError(\"Invalid input provided\")\n",
        "Raise a TypeError\n",
        "raise TypeError(\"Expected string, got integer\")\n",
        "Raise a custom message with any built-in exception\n",
        "raise FileNotFoundError(\"The specified file does not exist\")\n",
        "1. Re-raising Current Exception:\n",
        "try: # Some operation that might fail result = 10 / 0 except ZeroDivisionError: print(\"Logging the error...\") raise # Re-raises the current exception\n",
        "1. Raising Custom Exceptions:Define a custom exception class\n",
        "class CustomError(Exception): pass\n",
        "Raise the custom exception\n",
        "raise CustomError(\"This is a custom error message\")\n",
        "1. Conditional Exception Raising:\n",
        "def validate_age(age): if age < 0: raise ValueError(\"Age cannot be negative\") elif age > 150: raise ValueError(\"Age seems unrealistic\") return True\n",
        "Usage\n",
        "try: validate_age(-5) except ValueError as e: print(f\"Error: {e}\")\n",
        "1. Raising Exception with Traceback:\n",
        "import sys\n",
        "try: # Some operation 1/0 except: exc_type, exc_value, exc_traceback = sys.exc_info() raise exc_type(exc_value).with_traceback(exc_traceback)\n",
        "Best Practices:\n",
        "* Always provide meaningful error messages\n",
        "* Use appropriate built-in exception types when possible\n",
        "* Create custom exceptions for application-specific errors\n",
        "* Include relevant context information in error messages\n",
        "* Use raise without arguments to re-raise the current exception in except blocks\n",
        "\n",
        "Q25.Why is it important to use multithreading in certain applications?\n",
        "\n",
        "Ans Multithreading is important in certain applications for several key reasons:\n",
        "Improved Performance and Efficiency\n",
        "Allows multiple tasks to execute concurrently, making better use of system resourcesEnables parallel processing of independent operationsReduces overall execution time for CPU-intensive tasks\n",
        "Enhanced User Experience\n",
        "Prevents applications from becoming unresponsive during long-running operationsKeeps user interfaces reactive while background tasks are runningAllows users to continue interacting with the application while data is being processed\n",
        "Better Resource Utilization\n",
        "Takes advantage of multi-core processors by distributing work across coresMaximizes CPU utilization instead of leaving cores idleImproves system throughput by handling multiple requests simultaneously\n",
        "Handling I/O Operations\n",
        "Prevents blocking when waiting for file reads, network requests, or database queriesAllows other threads to continue working while some threads wait for I/O completionEssential for applications dealing with network communications or file processing\n",
        "Scalability\n",
        "Enables applications to handle multiple client requests simultaneously (web servers)Supports concurrent user sessions in multi-user applicationsAllows applications to scale with increasing workload demands\n",
        "Background Processing\n",
        "Enables background tasks like automatic saving, data synchronization, or cleanup operationsAllows periodic maintenance tasks without interrupting main application flowSupports real-time data processing and monitoring\n",
        "Common Use Cases:\n",
        "* Web servers handling multiple client requests\n",
        "* GUI applications performing background calculations\n",
        "* Data processing applications with parallel algorithms\n",
        "* Real-time systems requiring concurrent data streams\n",
        "* Applications with time-sensitive operations\n",
        "Important Considerations:\n",
        "* Thread safety and synchronization must be carefully managed\n",
        "* Overhead of context switching should be considered\n",
        "* Not all problems benefit from multithreading (some are inherently sequential)\n",
        "* Debugging multithreaded applications can be more complex\n",
        "\n",
        "       Practical questions"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q1.How can you open a file for writing in Python and write a string to it?\n",
        "\n",
        "\n",
        "How can you open a file for writing in Python and write a string to itTo open a file for writing in Python and write a string to it, you can use the open() function with the appropriate mode. Here are the most common approaches:\n",
        "\n",
        "Method 1: Basic file writing\n",
        "\n",
        "# Open file for writing (overwrites existing content)\n",
        "file = open(\"example.txt\", \"w\")\n",
        "file.write(\"Hello, World!\")\n",
        "file.close()\n",
        "\n",
        "Method 2: Using context manager (Recommended)\n",
        "\n",
        "# Using 'with' statement - automatically closes the file\n",
        "with open(\"example.txt\", \"w\") as file:\n",
        "    file.write(\"Hello, World!\")\n",
        "\n",
        "Method 3: Append mode\n",
        "\n",
        "# Open file for appending (adds to existing content)\n",
        "with open(\"example.txt\", \"a\") as file:\n",
        "    file.write(\"Additional text\")\n",
        "\n",
        "File modes explained:\n",
        "\n",
        "    * \"w\" - Write mode (overwrites existing file or creates new one)\n",
        "    * \"a\" - Append mode (adds to end of existing file or creates new one)\n",
        "    * \"x\" - Exclusive creation (fails if file already exists)\n",
        "\n",
        "Writing multiple lines:\n",
        "\n",
        "with open(\"example.txt\", \"w\") as file:\n",
        "    file.write(\"Line 1\\n\")\n",
        "    file.write(\"Line 2\\n\")\n",
        "    file.writelines([\"Line 3\\n\", \"Line 4\\n\"])\n",
        "\n",
        "Best practices:\n",
        "\n",
        "    1. Always use context managers (with statement) for automatic file closing\n",
        "    2. Handle exceptions when working with files\n",
        "    3. Specify encoding when working with text files: open(\"file.txt\", \"w\", encoding=\"utf-8\")"
      ],
      "metadata": {
        "id": "n31LcVBBCNZC"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "Q2. Write a Python program to read the contents of a file and print each line.\n",
        "print(\"Q2. Write a Python program to read the contents of a file and print each line.\\n\")\n",
        "\n",
        "# Method 1: Basic file reading with line numbers\n",
        "print(\"Method 1: Reading file with line numbers\")\n",
        "try:\n",
        "    with open(\"sample.txt\", \"r\") as file:\n",
        "        line_number = 1\n",
        "        for line in file:\n",
        "            print(f\"{line_number}: {line.strip()}\")\n",
        "            line_number += 1\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: File 'sample.txt' not found!\")\n",
        "print()\n",
        "\n",
        "# Method 2: Using enumerate for automatic line numbering\n",
        "print(\"Method 2: Using enumerate for line numbering\")\n",
        "try:\n",
        "    with open(\"sample.txt\", \"r\") as file:\n",
        "        for line_num, line in enumerate(file, 1):\n",
        "            print(f\"Line {line_num}: {line.rstrip()}\")\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: File 'sample.txt' not found!\")\n",
        "print()\n",
        "\n",
        "# Method 3: Reading all lines at once\n",
        "print(\"Method 3: Reading all lines at once\")\n",
        "try:\n",
        "    with open(\"sample.txt\", \"r\") as file:\n",
        "        lines = file.readlines()\n",
        "        for i, line in enumerate(lines, 1):\n",
        "            print(f\"{i}: {line.strip()}\")\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: File 'sample.txt' not found!\")\n",
        "print()\n",
        "\n",
        "# Method 4: Simple line-by-line reading\n",
        "print(\"Method 4: Simple line-by-line reading\")\n",
        "try:\n",
        "    with open(\"sample.txt\", \"r\") as file:\n",
        "        for line in file:\n",
        "            print(line.rstrip())  # rstrip() removes trailing newline\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: File 'sample.txt' not found!\")\n",
        "print()\n",
        "\n",
        "# Method 5: Function to read any file\n",
        "print(\"Method 5: Reusable function\")\n",
        "def read_and_print_file(filename):\n",
        "    \"\"\"\n",
        "    Function to read a file and print each line with line numbers\n",
        "    \"\"\"\n",
        "    try:\n",
        "        with open(filename, \"r\", encoding=\"utf-8\") as file:\n",
        "            print(f\"Contents of '{filename}':\")\n",
        "            print(\"-\" * 30)\n",
        "            for line_num, line in enumerate(file, 1):\n",
        "                print(f\"{line_num:2d}: {line.rstrip()}\")\n",
        "            print(\"-\" * 30)\n",
        "    except FileNotFoundError:\n",
        "        print(f\"Error: File '{filename}' not found!\")\n",
        "    except PermissionError:\n",
        "        print(f\"Error: Permission denied to read '{filename}'\")\n",
        "    except Exception as e:\n",
        "        print(f\"Error reading file: {e}\")\n",
        "\n",
        "# Test the function\n",
        "read_and_print_file(\"sample.txt\")"
      ],
      "metadata": {
        "id": "xhYuAVH8F8ff",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "b62a5ad7-29e6-4812-9c7e-51cd9adf9ba3"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Q2. Write a Python program to read the contents of a file and print each line.\n",
            "\n",
            "Method 1: Reading file with line numbers\n",
            "Error: File 'sample.txt' not found!\n",
            "\n",
            "Method 2: Using enumerate for line numbering\n",
            "Error: File 'sample.txt' not found!\n",
            "\n",
            "Method 3: Reading all lines at once\n",
            "Error: File 'sample.txt' not found!\n",
            "\n",
            "Method 4: Simple line-by-line reading\n",
            "Error: File 'sample.txt' not found!\n",
            "\n",
            "Method 5: Reusable function\n",
            "Error: File 'sample.txt' not found!\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q3.How would you handle a case where the file doesn't exist while trying to open it for reading?\n",
        "\n",
        "import os\n",
        "from pathlib import Path\n",
        "\n",
        "print(\"Q3. How would you handle a case where the file doesn't exist while trying to open it for reading?\\n\")\n",
        "\n",
        "# Method 1: Basic try-except with FileNotFoundError\n",
        "print(\"Method 1: Basic Exception Handling\")\n",
        "try:\n",
        "    with open(\"nonexistent_file.txt\", \"r\") as file:\n",
        "        content = file.read()\n",
        "        print(content)\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: The file does not exist!\")\n",
        "print()\n",
        "\n",
        "# Method 2: Multiple exception handling\n",
        "print(\"Method 2: Comprehensive Exception Handling\")\n",
        "def read_file_safe(filename):\n",
        "    try:\n",
        "        with open(filename, \"r\") as file:\n",
        "            return file.read()\n",
        "    except FileNotFoundError:\n",
        "        return f\"Error: File '{filename}' not found!\"\n",
        "    except PermissionError:\n",
        "        return f\"Error: Permission denied to access '{filename}'\"\n",
        "    except Exception as e:\n",
        "        return f\"Unexpected error: {e}\"\n",
        "\n",
        "result = read_file_safe(\"missing_file.txt\")\n",
        "print(result)\n",
        "print()\n",
        "\n",
        "# Method 3: Check file existence before opening\n",
        "print(\"Method 3: Check File Existence First\")\n",
        "filename = \"test_file.txt\"\n",
        "if os.path.exists(filename):\n",
        "    with open(filename, \"r\") as file:\n",
        "        print(file.read())\n",
        "else:\n",
        "    print(f\"File '{filename}' does not exist!\")\n",
        "print()\n",
        "\n",
        "# Method 4: Using pathlib (modern approach)\n",
        "print(\"Method 4: Using Pathlib\")\n",
        "file_path = Path(\"another_missing_file.txt\")\n",
        "if file_path.exists():\n",
        "    print(file_path.read_text())\n",
        "else:\n",
        "    print(f\"File '{file_path}' does not exist!\")\n",
        "print()\n",
        "\n",
        "# Method 5: Create file if it doesn't exist\n",
        "print(\"Method 5: Create File if Missing\")\n",
        "def read_or_create_file(filename):\n",
        "    try:\n",
        "        with open(filename, \"r\") as file:\n",
        "            return file.read()\n",
        "    except FileNotFoundError:\n",
        "        print(f\"File '{filename}' not found. Creating it...\")\n",
        "        with open(filename, \"w\") as file:\n",
        "            default_content = \"This file was created automatically.\"\n",
        "            file.write(default_content)\n",
        "        return default_content\n",
        "\n",
        "content = read_or_create_file(\"auto_created.txt\")\n",
        "print(f\"File content: {content}\")\n",
        "print()\n",
        "\n",
        "# Method 6: User-friendly function with multiple options\n",
        "print(\"Method 6: Complete File Handler Function\")\n",
        "def handle_file_reading(filename, create_if_missing=False, default_content=\"\"):\n",
        "    \"\"\"\n",
        "    Safely read a file with multiple error handling options\n",
        "    \"\"\"\n",
        "    try:\n",
        "        with open(filename, \"r\") as file:\n",
        "            content = file.read()\n",
        "            print(f\"Successfully read '{filename}':\")\n",
        "            print(content)\n",
        "            return content\n",
        "\n",
        "    except FileNotFoundError:\n",
        "        print(f\"FileNotFoundError: '{filename}' does not exist!\")\n",
        "\n",
        "        if create_if_missing:\n",
        "            print(f\"Creating '{filename}' with default content...\")\n",
        "            with open(filename, \"w\") as file:\n",
        "                file.write(default_content)\n",
        "            print(\"File created successfully!\")\n",
        "            return default_content\n",
        "        else:\n",
        "            print(\"Set create_if_missing=True to auto-create the file.\")\n",
        "            return None\n",
        "\n",
        "    except PermissionError:\n",
        "        print(f\"PermissionError: Cannot access '{filename}' - check permissions!\")\n",
        "        return None\n",
        "\n",
        "    except IsADirectoryError:\n",
        "        print(f\"IsADirectoryError: '{filename}' is a directory, not a file!\")\n",
        "        return None\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Unexpected error occurred: {type(e).__name__}: {e}\")\n",
        "        return None\n",
        "\n",
        "# Test the comprehensive function\n",
        "print(\"Testing with non-existent file:\")\n",
        "handle_file_reading(\"test1.txt\")\n",
        "\n",
        "print(\"\\nTesting with auto-creation:\")\n",
        "handle_file_reading(\"test2.txt\", create_if_missing=True, default_content=\"Hello from auto-created file!\")\n",
        "\n",
        "print(\"\\nTesting reading the created file:\")\n",
        "handle_file_reading(\"test2.txt\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 628
        },
        "id": "hYn9sknUHlCf",
        "outputId": "43626f32-3ace-4b79-de69-56dff43ddef8"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Object `reading` not found.\n",
            "Q3. How would you handle a case where the file doesn't exist while trying to open it for reading?\n",
            "\n",
            "Method 1: Basic Exception Handling\n",
            "Error: The file does not exist!\n",
            "\n",
            "Method 2: Comprehensive Exception Handling\n",
            "Error: File 'missing_file.txt' not found!\n",
            "\n",
            "Method 3: Check File Existence First\n",
            "File 'test_file.txt' does not exist!\n",
            "\n",
            "Method 4: Using Pathlib\n",
            "File 'another_missing_file.txt' does not exist!\n",
            "\n",
            "Method 5: Create File if Missing\n",
            "File 'auto_created.txt' not found. Creating it...\n",
            "File content: This file was created automatically.\n",
            "\n",
            "Method 6: Complete File Handler Function\n",
            "Testing with non-existent file:\n",
            "FileNotFoundError: 'test1.txt' does not exist!\n",
            "Set create_if_missing=True to auto-create the file.\n",
            "\n",
            "Testing with auto-creation:\n",
            "FileNotFoundError: 'test2.txt' does not exist!\n",
            "Creating 'test2.txt' with default content...\n",
            "File created successfully!\n",
            "\n",
            "Testing reading the created file:\n",
            "Successfully read 'test2.txt':\n",
            "Hello from auto-created file!\n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "'Hello from auto-created file!'"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "string"
            }
          },
          "metadata": {},
          "execution_count": 5
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "\n",
        "Q4.Write a Python script that reads from one file and writes its content to another file.\n",
        "\n",
        "# Q4: Write a Python script that reads from one file and writes its content to another file\n",
        "\n",
        "import os\n",
        "from pathlib import Path\n",
        "\n",
        "print(\"Q4. Writing a script to copy file content from one file to another\")\n",
        "print(\"=\" * 60)\n",
        "\n",
        "# Method 1: Basic file copy with exception handling\n",
        "print(\"Method 1: Basic File Copy\")\n",
        "\n",
        "def copy_file_basic(source_file, destination_file):\n",
        "    \"\"\"\n",
        "    Basic function to copy content from source to destination file\n",
        "    \"\"\"\n",
        "    try:\n",
        "        # Read from source file\n",
        "        with open(source_file, 'r') as source:\n",
        "            content = source.read()\n",
        "\n",
        "        # Write to destination file\n",
        "        with open(destination_file, 'w') as destination:\n",
        "            destination.write(content)\n",
        "\n",
        "        print(f\"Successfully copied content from '{source_file}' to '{destination_file}'\")\n",
        "        return True\n",
        "\n",
        "    except FileNotFoundError as e:\n",
        "        print(f\"Error: Source file '{source_file}' not found!\")\n",
        "        return False\n",
        "    except PermissionError as e:\n",
        "        print(f\"Error: Permission denied - {e}\")\n",
        "        return False\n",
        "    except Exception as e:\n",
        "        print(f\"Unexpected error: {e}\")\n",
        "        return False\n",
        "\n",
        "# Test basic copy\n",
        "copy_file_basic(\"sample.txt\", \"copy_of_sample.txt\")\n",
        "print()\n",
        "\n",
        "# Method 2: Advanced file copy with encoding and options\n",
        "print(\"Method 2: Advanced File Copy with Options\")\n",
        "\n",
        "def copy_file_advanced(source_file, destination_file, encoding='utf-8',\n",
        "                      append_mode=False, create_backup=False):\n",
        "    \"\"\"\n",
        "    Advanced file copy function with multiple options\n",
        "    \"\"\"\n",
        "    try:\n",
        "        # Create backup if requested\n",
        "        if create_backup and os.path.exists(destination_file):\n",
        "            backup_name = f\"{destination_file}.backup\"\n",
        "            copy_file_basic(destination_file, backup_name)\n",
        "            print(f\"Backup created: {backup_name}\")\n",
        "\n",
        "        # Determine write mode\n",
        "        write_mode = 'a' if append_mode else 'w'\n",
        "\n",
        "        # Copy file content\n",
        "        with open(source_file, 'r', encoding=encoding) as source:\n",
        "            with open(destination_file, write_mode, encoding=encoding) as destination:\n",
        "                content = source.read()\n",
        "                destination.write(content)\n",
        "\n",
        "        print(f\"Advanced copy completed: '{source_file}' → '{destination_file}'\")\n",
        "        print(f\"Mode: {'Append' if append_mode else 'Overwrite'}, Encoding: {encoding}\")\n",
        "        return True\n",
        "\n",
        "    except UnicodeDecodeError as e:\n",
        "        print(f\"Encoding error: {e}\")\n",
        "        return False\n",
        "    except Exception as e:\n",
        "        print(f\"Error during advanced copy: {e}\")\n",
        "        return False\n",
        "\n",
        "# Test advanced copy\n",
        "copy_file_advanced(\"sample.txt\", \"advanced_copy.txt\", create_backup=True)\n",
        "print()\n",
        "\n",
        "# Method 3: Copy with file size and line-by-line processing\n",
        "print(\"Method 3: Line-by-Line Copy with Statistics\")\n",
        "\n",
        "def copy_file_with_stats(source_file, destination_file):\n",
        "    \"\"\"\n",
        "    Copy file line by line and provide statistics\n",
        "    \"\"\"\n",
        "    try:\n",
        "        line_count = 0\n",
        "        char_count = 0\n",
        "\n",
        "        with open(source_file, 'r') as source:\n",
        "            with open(destination_file, 'w') as destination:\n",
        "                for line in source:\n",
        "                    destination.write(line)\n",
        "                    line_count += 1\n",
        "                    char_count += len(line)\n",
        "\n",
        "        print(f\"File copy completed with statistics:\")\n",
        "        print(f\"  Source: {source_file}\")\n",
        "        print(f\"  Destination: {destination_file}\")\n",
        "        print(f\"  Lines copied: {line_count}\")\n",
        "        print(f\"  Characters copied: {char_count}\")\n",
        "        return True\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Error during statistical copy: {e}\")\n",
        "        return False\n",
        "\n",
        "# Test statistical copy\n",
        "copy_file_with_stats(\"sample.txt\", \"stats_copy.txt\")\n",
        "print()\n",
        "\n",
        "# Method 4: Binary file copy (for any file type)\n",
        "print(\"Method 4: Binary File Copy (Universal)\")\n",
        "\n",
        "def copy_file_binary(source_file, destination_file, chunk_size=1024):\n",
        "    \"\"\"\n",
        "    Copy any type of file using binary mode\n",
        "    \"\"\"\n",
        "    try:\n",
        "        with open(source_file, 'rb') as source:\n",
        "            with open(destination_file, 'wb') as destination:\n",
        "                while True:\n",
        "                    chunk = source.read(chunk_size)\n",
        "                    if not chunk:\n",
        "                        break\n",
        "                    destination.write(chunk)\n",
        "\n",
        "        # Get file sizes\n",
        "        source_size = os.path.getsize(source_file)\n",
        "        dest_size = os.path.getsize(destination_file)\n",
        "\n",
        "        print(f\"Binary copy completed:\")\n",
        "        print(f\"  Source size: {source_size} bytes\")\n",
        "        print(f\"  Destination size: {dest_size} bytes\")\n",
        "        print(f\"  Copy successful: {source_size == dest_size}\")\n",
        "        return True\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Error during binary copy: {e}\")\n",
        "        return False\n",
        "\n",
        "# Test binary copy\n",
        "copy_file_binary(\"sample.txt\", \"binary_copy.txt\")\n",
        "print()\n",
        "\n",
        "# Method 5: Complete file copy utility with validation\n",
        "print(\"Method 5: Complete File Copy Utility\")\n",
        "\n",
        "def file_copy_utility(source_file, destination_file,\n",
        "                     overwrite=True, verify_copy=True):\n",
        "    \"\"\"\n",
        "    Complete file copy utility with validation\n",
        "    \"\"\"\n",
        "    try:\n",
        "        # Check if source exists\n",
        "        if not os.path.exists(source_file):\n",
        "            print(f\"Error: Source file '{source_file}' does not exist!\")\n",
        "            return False\n",
        "\n",
        "        # Check if destination exists and handle overwrite\n",
        "        if os.path.exists(destination_file) and not overwrite:\n",
        "            print(f\"Error: Destination '{destination_file}' exists and overwrite=False\")\n",
        "            return False\n",
        "\n",
        "        # Perform the copy\n",
        "        with open(source_file, 'r') as source:\n",
        "            content = source.read()\n",
        "\n",
        "        with open(destination_file, 'w') as destination:\n",
        "            destination.write(content)\n",
        "\n",
        "        # Verify copy if requested\n",
        "        if verify_copy:\n",
        "            with open(source_file, 'r') as source:\n",
        "                original_content = source.read()\n",
        "            with open(destination_file, 'r') as destination:\n",
        "                copied_content = destination.read()\n",
        "\n",
        "            if original_content == copied_content:\n",
        "                print(f\"✓ File copy verified successful!\")\n",
        "            else:\n",
        "                print(f\"⚠ Warning: Copy verification failed!\")\n",
        "                return False\n",
        "\n",
        "        print(f\"File copy utility completed: '{source_file}' → '{destination_file}'\")\n",
        "        return True\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Error in file copy utility: {e}\")\n",
        "        return False\n",
        "\n",
        "# Test complete utility\n",
        "file_copy_utility(\"sample.txt\", \"utility_copy.txt\")\n",
        "print()\n",
        "\n",
        "# Method 6: Multiple file copy with progress\n",
        "print(\"Method 6: Batch File Copy\")\n",
        "\n",
        "def copy_multiple_files(file_pairs):\n",
        "    \"\"\"\n",
        "    Copy multiple files at once\n",
        "    file_pairs: list of tuples [(source1, dest1), (source2, dest2), ...]\n",
        "    \"\"\"\n",
        "    successful_copies = 0\n",
        "    failed_copies = 0\n",
        "\n",
        "    print(f\"Starting batch copy of {len(file_pairs)} files...\")\n",
        "\n",
        "    for i, (source, destination) in enumerate(file_pairs, 1):\n",
        "        print(f\"[{i}/{len(file_pairs)}] Copying '{source}' → '{destination}'\")\n",
        "\n",
        "        if copy_file_basic(source, destination):\n",
        "            successful_copies += 1\n",
        "        else:\n",
        "            failed_copies += 1\n",
        "\n",
        "    print(f\"\\nBatch copy completed:\")\n",
        "    print(f\"  Successful: {successful_copies}\")\n",
        "    print(f\"  Failed: {failed_copies}\")\n",
        "\n",
        "    return successful_copies, failed_copies\n",
        "\n",
        "# Test batch copy\n",
        "file_pairs = [\n",
        "    (\"sample.txt\", \"batch_copy1.txt\"),\n",
        "    (\"sample.txt\", \"batch_copy2.txt\")\n",
        "]\n",
        "copy_multiple_files(file_pairs)\n",
        "print()\n",
        "\n",
        "# Method 7: Interactive file copy\n",
        "print(\"Method 7: User-Friendly File Copy Function\")\n",
        "\n",
        "def interactive_file_copy():\n",
        "    \"\"\"\n",
        "    Interactive function that prompts for file names\n",
        "    \"\"\"\n",
        "    print(\"Interactive File Copy Tool\")\n",
        "    print(\"-\" * 25)\n",
        "\n",
        "    source = input(\"Enter source file name: \").strip()\n",
        "    if not source:\n",
        "        print(\"No source file specified!\")\n",
        "        return\n",
        "\n",
        "    destination = input(\"Enter destination file name: \").strip()\n",
        "    if not destination:\n",
        "        print(\"No destination file specified!\")\n",
        "        return\n",
        "\n",
        "    # Check if destination exists\n",
        "    if os.path.exists(destination):\n",
        "        overwrite = input(f\"'{destination}' exists. Overwrite? (y/n): \").lower()\n",
        "        if overwrite != 'y':\n",
        "            print(\"Copy cancelled.\")\n",
        "            return\n",
        "\n",
        "    # Perform copy\n",
        "    success = copy_file_basic(source, destination)\n",
        "    if success:\n",
        "        print(\"File copy completed successfully! ✓\")\n",
        "    else:\n",
        "        print(\"File copy failed! ✗\")\n",
        "\n",
        "# Uncomment the next line to test interactive copy\n",
        "# interactive_file_copy()\n",
        "\n",
        "print(\"All file copy methods demonstrated!\")"
      ],
      "metadata": {
        "id": "Pf783siasrMm",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "fe1f2339-8c88-496d-ce7b-f2dfcce10801"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Q4. Writing a script to copy file content from one file to another\n",
            "============================================================\n",
            "Method 1: Basic File Copy\n",
            "Error: Source file 'sample.txt' not found!\n",
            "\n",
            "Method 2: Advanced File Copy with Options\n",
            "Error during advanced copy: [Errno 2] No such file or directory: 'sample.txt'\n",
            "\n",
            "Method 3: Line-by-Line Copy with Statistics\n",
            "Error during statistical copy: [Errno 2] No such file or directory: 'sample.txt'\n",
            "\n",
            "Method 4: Binary File Copy (Universal)\n",
            "Error during binary copy: [Errno 2] No such file or directory: 'sample.txt'\n",
            "\n",
            "Method 5: Complete File Copy Utility\n",
            "Error: Source file 'sample.txt' does not exist!\n",
            "\n",
            "Method 6: Batch File Copy\n",
            "Starting batch copy of 2 files...\n",
            "[1/2] Copying 'sample.txt' → 'batch_copy1.txt'\n",
            "Error: Source file 'sample.txt' not found!\n",
            "[2/2] Copying 'sample.txt' → 'batch_copy2.txt'\n",
            "Error: Source file 'sample.txt' not found!\n",
            "\n",
            "Batch copy completed:\n",
            "  Successful: 0\n",
            "  Failed: 2\n",
            "\n",
            "Method 7: User-Friendly File Copy Function\n",
            "All file copy methods demonstrated!\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q5. How would you catch and handle division by zero error in Python?\n",
        "\n",
        "# Corrected code for handling division by zero error in Python\n",
        "\n",
        "try:\n",
        "    numerator = 10\n",
        "    denominator = 0\n",
        "    result = numerator / denominator\n",
        "    print(\"Result:\", result)\n",
        "except ZeroDivisionError:\n",
        "    print(\"Error: Division by zero is not allowed.\")"
      ],
      "metadata": {
        "id": "3msTByMBu-ai",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "6a03faa9-d51a-4cdc-99ca-7d49179d929d"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Error: Division by zero is not allowed.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q6. Write a Python program that logs an error message to a log file when a division by zero exception occurs.\n",
        "\n",
        "import logging\n",
        "\n",
        "# Configure logging\n",
        "logging.basicConfig(filename='error_log.log', level=logging.ERROR,\n",
        "                    format='%(asctime)s - %(levelname)s - %(message)s')\n",
        "\n",
        "try:\n",
        "    numerator = 10\n",
        "    denominator = 0\n",
        "    result = numerator / denominator\n",
        "    print(\"Result:\", result)\n",
        "except ZeroDivisionError as e:\n",
        "    logging.error(\"Division by zero error occurred: %s\", e)\n",
        "    print(\"Error: Division by zero is not allowed. Check the log file for details.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "CRYNKCf4vrir",
        "outputId": "0b93d124-c38f-4597-9933-3af70b29d71b"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "ERROR:root:Division by zero error occurred: division by zero\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Error: Division by zero is not allowed. Check the log file for details.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q7. How do you log information at different levels (INFO, ERROR, WARNING) in Python using the logging module\n",
        "import logging\n",
        "\n",
        "# Configure the logging settings\n",
        "logging.basicConfig(\n",
        "    filename='app.log',  # Log file name\n",
        "    level=logging.DEBUG,  # Set the logging level to DEBUG or higher\n",
        "    format='%(asctime)s - %(levelname)s - %(message)s'  # Log message format\n",
        ")\n",
        "\n",
        "# Logging messages at different levels\n",
        "logging.debug(\"This is a DEBUG message, useful for debugging.\")\n",
        "logging.info(\"This is an INFO message, generally for informational purposes.\")\n",
        "logging.warning(\"This is a WARNING message, indicating a potential issue.\")\n",
        "logging.error(\"This is an ERROR message, indicating that an error has occurred.\")\n",
        "logging.critical(\"This is a CRITICAL message, indicating a severe error.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "CJPN5qBIw58O",
        "outputId": "20717d6e-be5b-4c78-a7cf-00be23dca1ca"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "WARNING:root:This is a WARNING message, indicating a potential issue.\n",
            "ERROR:root:This is an ERROR message, indicating that an error has occurred.\n",
            "CRITICAL:root:This is a CRITICAL message, indicating a severe error.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q8. Write a program to handle a file opening error using exception handling\n",
        "\n",
        "try:\n",
        "    # Attempt to open a file\n",
        "    file = open(\"non_existent_file.txt\", \"r\")\n",
        "    content = file.read()\n",
        "    print(content)\n",
        "    file.close()\n",
        "except FileNotFoundError as e:\n",
        "    # Handle the file not found error\n",
        "    print(\"Error: The file you are trying to open does not exist.\")\n",
        "    print(f\"Details: {e}\")\n",
        "except Exception as e:\n",
        "    # Handle any other exceptions\n",
        "    print(\"An unexpected error occurred.\")\n",
        "    print(f\"Details: {e}\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "T-53tD8TxUqC",
        "outputId": "76853c90-2eab-439c-b6c2-8c2177846c5a"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Error: The file you are trying to open does not exist.\n",
            "Details: [Errno 2] No such file or directory: 'non_existent_file.txt'\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q9. How can you read a file line by line and store its content in a list in Python\n",
        "\n",
        "# Open the file in read mode\n",
        "try:\n",
        "    with open(\"filename.txt\", \"r\") as file:\n",
        "        # Read all lines and store them in a list\n",
        "        lines = file.readlines()\n",
        "\n",
        "    # Strip newline characters and print the list\n",
        "    lines = [line.strip() for line in lines]\n",
        "    print(lines)\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: The file does not exist.\")\n",
        "except Exception as e:\n",
        "    print(f\"An unexpected error occurred: {e}\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ivliCF4Uxn2i",
        "outputId": "740d7dd6-c106-44d8-dcc2-3daceedf9470"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Error: The file does not exist.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q10. How can you append data to an existing file in Python?\n",
        "\n",
        "# Open the file in append mode\n",
        "try:\n",
        "    with open(\"filename.txt\", \"a\") as file:\n",
        "        # Append data to the file\n",
        "        file.write(\"\\nThis is the new data being appended.\")\n",
        "        print(\"Data appended successfully.\")\n",
        "except FileNotFoundError:\n",
        "    print(\"Error: The file does not exist.\")\n",
        "except Exception as e:\n",
        "    print(f\"An unexpected error occurred: {e}\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "EEIv_9ZPx2ut",
        "outputId": "212daeeb-5dbc-4b4b-efa4-70422b6d3307"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Data appended successfully.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q11.Write a Python program that uses a try-except block to handle an error when attempting to access a dictionary key that doesn't exist\n",
        "\n",
        "# Define a dictionary\n",
        "my_dict = {\"name\": \"Alice\", \"age\": 25}\n",
        "\n",
        "# Try to access a key that might not exist\n",
        "try:\n",
        "    value = my_dict[\"address\"]\n",
        "    print(f\"The value is: {value}\")\n",
        "except KeyError:\n",
        "    print(\"Error: The specified key does not exist in the dictionary.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "QrPdi7u2yE0o",
        "outputId": "796ab897-c117-4b0e-a2be-61838b4e3371"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Error: The specified key does not exist in the dictionary.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q12.Write a program that demonstrates using multiple except blocks to handle different types of exceptions\n",
        "\n",
        "# Demonstrating multiple except blocks to handle different exceptions\n",
        "\n",
        "try:\n",
        "    # Attempting to divide by zero\n",
        "    result = 10 / 0\n",
        "    print(f\"Result: {result}\")\n",
        "\n",
        "    # Attempting to access an invalid index in a list\n",
        "    my_list = [1, 2, 3]\n",
        "    print(my_list[5])\n",
        "\n",
        "    # Attempting to access a non-existent dictionary key\n",
        "    my_dict = {\"name\": \"Alice\", \"age\": 25}\n",
        "    print(my_dict[\"address\"])\n",
        "\n",
        "except ZeroDivisionError:\n",
        "    print(\"Error: Division by zero is not allowed.\")\n",
        "\n",
        "except IndexError:\n",
        "    print(\"Error: List index out of range.\")\n",
        "\n",
        "except KeyError:\n",
        "    print(\"Error: The specified key does not exist in the dictionary.\")\n",
        "\n",
        "except Exception as e:\n",
        "    print(f\"An unexpected error occurred: {e}\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "gbaMS-9fzFHH",
        "outputId": "8cff10ed-214f-42da-d86c-87afe772fa4e"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Error: Division by zero is not allowed.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "\n",
        "Q13.How would you check if a file exists before attempting to read it in Python\n",
        "\n",
        "import os\n",
        "from pathlib import Path\n",
        "\n",
        "file_path = \"example.txt\"\n",
        "\n",
        "# Using os.path.exists()\n",
        "if os.path.exists(file_path):\n",
        "    with open(file_path, 'r') as file:\n",
        "        content = file.read()\n",
        "        print(\"Using os.path.exists():\")\n",
        "        print(content)\n",
        "else:\n",
        "    print(f\"The file '{file_path}' does not exist (checked using os.path.exists()).\")\n",
        "\n",
        "# Using pathlib.Path\n",
        "file_path_obj = Path(file_path)\n",
        "\n",
        "if file_path_obj.exists():\n",
        "    with file_path_obj.open('r') as file:\n",
        "        content = file.read()\n",
        "        print(\"\\nUsing pathlib.Path:\")\n",
        "        print(content)\n",
        "else:\n",
        "    print(f\"The file '{file_path}' does not exist (checked using pathlib.Path).\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "wfnbMerd0Lgg",
        "outputId": "9129a406-65c9-4035-d23c-b969d52dd8fb"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The file 'example.txt' does not exist (checked using os.path.exists()).\n",
            "The file 'example.txt' does not exist (checked using pathlib.Path).\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q14.Write a program that uses the logging module to log both informational and error messages.\n",
        "\n",
        "import logging\n",
        "\n",
        "# Configure the logging module\n",
        "logging.basicConfig(\n",
        "    level=logging.DEBUG,\n",
        "    format='%(asctime)s - %(levelname)s - %(message)s',\n",
        "    filename='app.log',\n",
        "    filemode='w'  # Overwrite the log file each time the program runs\n",
        ")\n",
        "\n",
        "# Log informational messages\n",
        "logging.info(\"This is an informational message.\")\n",
        "logging.debug(\"This is a debug message for detailed troubleshooting.\")\n",
        "\n",
        "try:\n",
        "    # Simulate a block of code that may raise an exception\n",
        "    result = 10 / 0  # This will raise a ZeroDivisionError\n",
        "except ZeroDivisionError as e:\n",
        "    # Log the error message\n",
        "    logging.error(\"An error occurred: Division by zero.\", exc_info=True)\n",
        "\n",
        "# Log a warning message\n",
        "logging.warning(\"This is a warning message.\")\n",
        "\n",
        "# Log a critical message\n",
        "logging.critical(\"This is a critical message indicating a severe issue.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "BYm0yK4I1kG9",
        "outputId": "6bd18662-a57f-488c-a72c-1270d7283eb9"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "ERROR:root:An error occurred: Division by zero.\n",
            "Traceback (most recent call last):\n",
            "  File \"<ipython-input-16-43043b358e8c>\", line 17, in <cell line: 0>\n",
            "    result = 10 / 0  # This will raise a ZeroDivisionError\n",
            "             ~~~^~~\n",
            "ZeroDivisionError: division by zero\n",
            "WARNING:root:This is a warning message.\n",
            "CRITICAL:root:This is a critical message indicating a severe issue.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q15.Write a Python program that prints the content of a file and handles the case when the file is empty\n",
        "\n",
        "def print_file_content(file_path):\n",
        "    try:\n",
        "        # Open the file in read mode\n",
        "        with open(file_path, 'r') as file:\n",
        "            content = file.read()\n",
        "\n",
        "            # Check if the file is empty\n",
        "            if not content:\n",
        "                print(\"The file is empty.\")\n",
        "            else:\n",
        "                print(\"File Content:\")\n",
        "                print(content)\n",
        "    except FileNotFoundError:\n",
        "        print(f\"Error: The file '{file_path}' does not exist.\")\n",
        "    except Exception as e:\n",
        "        print(f\"An unexpected error occurred: {e}\")\n",
        "\n",
        "# Example usage\n",
        "file_path = \"filename.txt\"  # Replace with your file path\n",
        "print_file_content(file_path)"
      ],
      "metadata": {
        "id": "aDoJiLgo2Lbd",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "9a10fc41-bbe6-4d9d-c906-824b61c9f6fa"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "File Content:\n",
            "\n",
            "This is the new data being appended.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "\n",
        "Q16.Demonstrate how to use memory profiling to check the memory usage of a small program\n",
        "# Install the memory_profiler package before running this code\n",
        "# pip install memory-profiler\n",
        "\n",
        "from memory_profiler import profile\n",
        "\n",
        "@profile\n",
        "def memory_intensive_function():\n",
        "    # Example of a memory-intensive operation\n",
        "    large_list = [i for i in range(1000000)]  # Creating a large list\n",
        "    return sum(large_list)\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    memory_intensive_function()"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 679
        },
        "id": "7W8Ogd6O3cce",
        "outputId": "60743c43-52e8-4469-ff33-df2eb2918eb0"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "error",
          "ename": "ModuleNotFoundError",
          "evalue": "No module named 'memory_profiler'",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-21-9ecfcb7cf374>\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;31m# pip install memory-profiler\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m \u001b[0;32mfrom\u001b[0m \u001b[0mmemory_profiler\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mprofile\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m \u001b[0;34m@\u001b[0m\u001b[0mprofile\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'memory_profiler'",
            "",
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0;32m\nNOTE: If your import is failing due to a missing package, you can\nmanually install dependencies using either !pip or !apt.\n\nTo view examples of installing some common dependencies, click the\n\"Open Examples\" button below.\n\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n"
          ],
          "errorDetails": {
            "actions": [
              {
                "action": "open_url",
                "actionText": "Open Examples",
                "url": "/notebooks/snippets/importing_libraries.ipynb"
              }
            ]
          }
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q17.Write a Python program to create and write a list of numbers to a file, one number per line\n",
        "\n",
        "# Python program to create and write a list of numbers to a file, one number per line\n",
        "\n",
        "def write_numbers_to_file(file_path, numbers):\n",
        "    try:\n",
        "        # Open the file in write mode\n",
        "        with open(file_path, 'w') as file:\n",
        "            for number in numbers:\n",
        "                file.write(f\"{number}\\n\")  # Write each number followed by a newline\n",
        "        print(f\"Numbers successfully written to {file_path}\")\n",
        "    except Exception as e:\n",
        "        print(f\"An error occurred: {e}\")\n",
        "\n",
        "# Example usage\n",
        "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # List of numbers\n",
        "file_path = \"numbers.txt\"  # File to write the numbers\n",
        "write_numbers_to_file(file_path, numbers)"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "fJZSVcS733Q-",
        "outputId": "9800c18a-1074-406f-cca3-7873790e3ed7"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Numbers successfully written to numbers.txt\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q18.How would you implement a basic logging setup that logs to a file with rotation after 1MB\n",
        "\n",
        "import logging\n",
        "from logging.handlers import RotatingFileHandler\n",
        "\n",
        "# Define the logger\n",
        "logger = logging.getLogger(\"MyLogger\")\n",
        "logger.setLevel(logging.DEBUG)  # Set the logging level\n",
        "\n",
        "# Create a RotatingFileHandler\n",
        "handler = RotatingFileHandler(\n",
        "    \"app.log\",  # Log file name\n",
        "    maxBytes=1 * 1024 * 1024,  # 1MB size limit\n",
        "    backupCount=5  # Keep up to 5 backup files\n",
        ")\n",
        "\n",
        "# Define the log format\n",
        "formatter = logging.Formatter(\n",
        "    \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n",
        ")\n",
        "handler.setFormatter(formatter)\n",
        "\n",
        "# Add the handler to the logger\n",
        "logger.addHandler(handler)\n",
        "\n",
        "# Example usage\n",
        "logger.debug(\"This is a debug message\")\n",
        "logger.info(\"This is an info message\")\n",
        "logger.warning(\"This is a warning message\")\n",
        "logger.error(\"This is an error message\")\n",
        "logger.critical(\"This is a critical message\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "BPGx2l7t5cKm",
        "outputId": "3d7711b0-c38c-4725-cd15-1a0e3491e8dd"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "DEBUG:MyLogger:This is a debug message\n",
            "INFO:MyLogger:This is an info message\n",
            "WARNING:MyLogger:This is a warning message\n",
            "ERROR:MyLogger:This is an error message\n",
            "CRITICAL:MyLogger:This is a critical message\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q19.Write a program that handles both IndexError and KeyError using a try-except block\n",
        "\n",
        "    # Code that may raise IndexError\n",
        "    my_list = [1, 2, 3]\n",
        "    print(my_list[5])  # This will raise an IndexError\n",
        "\n",
        "    # Code that may raise KeyError\n",
        "    my_dict = {\"a\": 1, \"b\": 2}\n",
        "    print(my_dict[\"c\"])  # This will raise a KeyError\n",
        "\n",
        "except IndexError as e:\n",
        "    print(f\"IndexError occurred: {e}\")\n",
        "\n",
        "except KeyError as e:\n",
        "    print(f\"KeyError occurred: {e}\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "PuR8dKzd5yDd",
        "outputId": "2bcfadb3-ea9d-4f60-9e2f-d419ad2a78dd"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "IndexError occurred: list index out of range\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q20.How would you open a file and read its contents using a context manager in Python\n",
        "\n",
        "# Open the file using a context manager\n",
        "with open(\"filename.txt\", \"r\") as file:\n",
        "    # Read the contents of the file\n",
        "    contents = file.read()\n",
        "\n",
        "# Print the contents\n",
        "print(contents)"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "5UkOjHnX6QYl",
        "outputId": "2496bac0-0162-4475-de53-32015fe331f6"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\n",
            "This is the new data being appended.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q21. Write a Python program that reads a file and prints the number of occurrences of a specific word\n",
        "\n",
        "# Python program to read a file and count occurrences of a specific word\n",
        "\n",
        "# Define the file name and the word to search for\n",
        "file_name = \"filename.txt\"\n",
        "word_to_search = \"specific_word\"\n",
        "\n",
        "# Initialize a counter\n",
        "word_count = 0\n",
        "\n",
        "# Open the file using a context manager\n",
        "with open(file_name, \"r\") as file:\n",
        "    # Read the file line by line\n",
        "    for line in file:\n",
        "        # Split the line into words\n",
        "        words = line.split()\n",
        "        # Count occurrences of the specific word in the current line\n",
        "        word_count += words.count(word_to_search)\n",
        "\n",
        "# Print the result\n",
        "print(f\"The word '{word_to_search}' occurred {word_count} times in the file.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "axt_M6856iQV",
        "outputId": "3fedd44f-b09e-4aed-8ceb-ccbaea4030e7"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The word 'specific_word' occurred 0 times in the file.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q22.How can you check if a file is empty before attempting to read its contents?\n",
        "\n",
        "import os\n",
        "\n",
        "# Specify the file name\n",
        "file_name = \"filename.txt\"\n",
        "\n",
        "# Check if the file is empty\n",
        "if os.path.exists(file_name) and os.path.getsize(file_name) == 0:\n",
        "    print(f\"The file '{file_name}' is empty.\")\n",
        "else:\n",
        "    print(f\"The file '{file_name}' is not empty.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "h_NQ7NEo6ycC",
        "outputId": "f751fd7f-adaf-46d6-ad9a-7a260bf35142"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The file 'filename.txt' is not empty.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "Q23.Write a Python program that writes to a log file when an error occurs during file handling\n",
        "\n",
        "import logging\n",
        "\n",
        "# Configure logging\n",
        "logging.basicConfig(filename='error_log.log', level=logging.ERROR,\n",
        "                    format='%(asctime)s - %(levelname)s - %(message)s')\n",
        "\n",
        "try:\n",
        "    # Attempt to open a file that may not exist\n",
        "    with open('non_existent_file.txt', 'r') as file:\n",
        "        content = file.read()\n",
        "except FileNotFoundError as e:\n",
        "    # Log the error if the file is not found\n",
        "    logging.error(f\"File not found: {e}\")\n",
        "    print(\"An error occurred. Check the log file for details.\")\n",
        "except Exception as e:\n",
        "    # Log any other exceptions\n",
        "    logging.error(f\"An unexpected error occurred: {e}\")\n",
        "    print(\"An unexpected error occurred. Check the log file for details.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Rbk4AmqY7Bq7",
        "outputId": "776efbf8-7845-4ed5-9105-0f95532b5a1d"
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "ERROR:root:File not found: [Errno 2] No such file or directory: 'non_existent_file.txt'\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "An error occurred. Check the log file for details.\n"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}